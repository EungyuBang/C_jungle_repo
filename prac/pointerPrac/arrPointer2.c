#include <stdio.h>
// 1. 배열 값 바꾸기
int main() {
  int arr[5] = {10,20,30,40,50};
  int *p = arr; // p는 배열의 시작점이 됨 arr[0]

  // 포인터를 이용해서 arr[2] 값을 99로 바꿈
  *(p+2) = 99;

  for(int i =0; i < 5; i++) {
    printf("arr[%d] = %d, *(p+%d) = %d\n", i, arr[i], i, *(p+i));
  }
  return 0;
}

// 2. 배열 합 구하기
 int main() {
   int arr[4] = {10,20,30,40};
   //         arr[0][1][2][3]
   // 배열은 메모리에서 연속된 공간에 저장됨
   int *p = arr ;
   //p에 각 arr의 주소값 들어가 있음
   // 10 -> 0x100
   // 20 -> 0x104
   // 30 -> 0x108
   // 40 -> 0x10c
   int sum = 0 ;
   // sum = 0 으로 초기화
   for(int i = 0; i < 4 ; i++) {
     sum += *(p + i);
   }
  /*
  포인터 산술 (p + i)
  p가 가리키는 주소를 기준으로 i만큼 **타입 단위(int)**로 이동
  즉, p + 1은 실제로 주소 + sizeof(int) 만큼 이동
  p    = 0x100 -> *(p+0) = 10
  p+1  = 0x100 + 4 = 0x104 -> *(p+1) = 20
  p+2  = 0x100 + 8 = 0x108 -> *(p+2) = 30
  p+3  = 0x100 +12 = 0x10C -> *(p+3) = 40
  핵심: 포인터에 1을 더하면, 타입 크기만큼 증가
  int * → 1 증가 = 4바이트 이동
  char * → 1 증가 = 1바이트 이동
  double * → 1 증가 = 8바이트 이동 (환경에 따라 다름)
  */
   printf("배열 합 = %d\n", sum);
   return 0;
}

// 3. 포인터로 배열 역순 출력
int main() {
  int arr[5] = {1,2,3,4,5};
  int *p = arr + 4; // 배열 마지막 원소 주소로 포인터 이동시켜버림

  for(int i = 0 ; i<5; i++) {
    printf("%d", *(p-i)); // 포인터를 뒤로 이동시키면서 값 출력
  }
  printf("\n");
  return 0;
}